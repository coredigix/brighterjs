;(function(){	'use strict';	/** * extend for array */function ArrayUtils(array){	if(new.target)		throw new Error('unsupported operator "new"');	else if(Array.isArray(array)){		Object.setPrototypeOf(array, ArrayUtilsFactory.prototype);	}	else throw new Error('The given argument is not an array.');	return array;}class ArrayUtilsFactory extends Array{	/**	 * clone an array	 * we use "for" instead of "slice" and "push.apply" because it's faster	 */	clone(){		var lst	= new arrayUtils();		for(var i = 0, len = this.length; i < len; ++i)			lst.push(this[i]);		return lst;	}	/**	 * get first element that matches a condition	 * @param {function} 	condition 	desired condition	 * @param {int} 		index 		optional start index	 * @param {int} 		lastIndex 	optional last index	 */	first(condition, index = 0, lastIndex){		var len	= this.length;		if(len > 0){			if(arguments.length === 0)				return this[0];			else {				if(lastIndex && lastIndex < len) len = lastIndex + 1;				if(index < 0) throw new Error('incorrect index: ' + index);				while(index < len){					if(condition(this[index], index, this))						return this[index];					++index;				}			}		}	}	/**	 * get the last element that matches a condition	 * @param {function} condition desired condition	 * @param {int} index last index	 */	last(condition, beginIndex = 0, lastIndex){		var len	= this.length - 1;		if(len > -1){			if(arguments.length === 0)				return this[len];			else {				if(lastIndex && lastIndex <= len) len = lastIndex;				if(beginIndex < 0) throw new Error('incorrect index: ' + index);				for(var i = len; i >= beginIndex; i--){					if(condition(this[i], i, this))						return this[i];				}			}		}	}	/** contains */	contains(ele){ return this.indexOf(ele) !== -1; }	push(){super.push.apply(this, arguments); return this;}	unshift(){super.unshift.apply(this, arguments); return this;}	/**	 * each	 */	each(cb){		for(var i=0, len = this.length; i < len; ++i){			if(cb(this[i], i) === false)				break;		}		return this;	}	/** remove all elemnts */	clear(){		this.splice(0);		return this;	}	unique(){		return this.filter((ele, indx) => {			return this.indexOf(ele) === indx;		});	}	eq(index){		if(index < 0){			index += this.length;			if(index < 0) return undefined;		}		return this[index];	}}Object.defineProperties(ArrayUtilsFactory.prototype, {	contains	: {value: Array.prototype.includes},	has			: {value: Array.prototype.includes},	duplicate	: {value: ArrayUtilsFactory.prototype.clone}})// instanceofArrayUtils.prototype = ArrayUtilsFactory.prototype;// Array.from(arrayLikeElement, mapFunction)// Array.copyWithin// Array.fill// // // every// some// // reverse// sort// concat// splice// // map// reduce// reduceRight// // indexOf// join// lastIndexOf// slice// // entries// filter// find// findIndex// // forEach	const _COLLECTIONOP	= {		all	: Symbol(),		not	: Symbol(),		or	: Symbol()	};	class $$Collection	extends ArrayUtils {		// make array operations spreadable		get [Symbol.isConcatSpreadable](){ return true; }		push(){ super.push($$(arguments)); }		unshift(){ super.unshift($$(arguments)); }		concat(){ super.concat($$(arguments))}		splice(start, rmCount){			if(arguments.length > 2)				super.splice(start, nbrCount, $$(Array.slice.call(arguments, 2)));			else super.splice(start, nbrCount);		}		first(){ return $$(super.first.call(arguments)); }		last(){ return $$(super.last.call(arguments)); }		firstTag(predicat, start, end){ return $$(super.first(ele => ele && ele.nodeType === 1 && predicat, start, end)) }		lastTag(predicat, start, end){ return $$(super.last(ele => ele && ele.nodeType === 1 && predicat, start, end)) }		// Each		// each tag (tag only, exclude attributeNode, commentNode, textNode, ...)		eachTag(cb){			return this.each(ele => ele && ele.nodeType === 1 ? cb(ele, i) : true );		}		get tags(){			return this.filter(ele => ele && ele.nodeType === 1);		}		// operators		get all(){			this[_COLLECTIONOP.all] = true;			return this;		}		get or(){			this[_COLLECTIONOP.or] = true;			return this;		}		get not(){			this[_COLLECTIONOP.not] = true;			return this;		}		_op(op, fxTrue, fxFalse){			if(this[_COLLECTIONOP[op]] === true){				this[_COLLECTIONOP[op]] = false;				fxTrue();			}			else fxFalse;			return this;		}	}	/**	 * this contains main function of brighter that creates HTML and SVG elements	 *	 * 	 */	function $$(){	}	$$.prototype	= $$Collection.prototype;	/**	 * thos functions add plugins to brighter	 */	Object.defineProperties($$, {		rootPlugin	: { value : plugins => _addPlugin(plugins, true), },		plugin		: { value : plugins => _addPlugin(plugins, false) }	});	function _addPlugin(plugins, isRoot){		var i, dscptr;		plugins	= Object.getOwnPropertyDescriptors(plugins);		for(i in plugins){			dscptr	= plugins[i];			dscptr.configurable	= false;			dscptr.enumerable	= false;			dscptr.writable		= false;		}		Object.defineProperties(isRoot ? $$ : $$.prototype, dscptr);	}	$$.plugin({		// get or set attributes		// attr('attrName')		// get attribute value		// attr({key: value})	// set attributes		// attr(namespace, {key: value})	// set attributes with namespace		attr	: function(){			var attributes, namespace, key;			// get all attributes			if(arguments.length === 0){			} else if(arguments.length === 1){				attributes = arguments[0];				if(typeof arguments === 'string'){				} else {					this.eachTag(ele => {						for(key in attributes)							ele.setAttribute(namespace, key, attributes[key]);					});				}			} else if(arguments.length === 2){				namespace	= arguments[0];				attributes	= arguments[1];				this.eachTag(ele => {					for(key in attributes)						ele.setAttributeNS(namespace, key, attributes[key]);				});			}			else throw new Error('uncorrect arguments length');			return this;		}	});
	//=inculde assert.js	// make it global	window.$$ = window.BrighterJS = $$;})();