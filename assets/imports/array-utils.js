/** * extend for array */function ArrayUtils(array){	if(new.target)		throw new Error('unsupported operator "new"');	else if(Array.isArray(array)){		Object.setPrototypeOf(array, ArrayUtilsFactory.prototype);	}	else throw new Error('The given argument is not an array.');	return array;}ArrayUtils.spreadable	= Symbol('ArrayUtils-spreadable');	// make push, unshift and concat spreadableArrayUtils.control		= Symbol('ArrayUtils-control');		// control on elements before adding theme to arrayArrayUtils.isArrayLike	= function(arr){	return Array.isArray(arr) 		|| (typeof arr === 'object') && (arr !== null) && (typeof arr.length === 'number');}class ArrayUtilsFactory extends Array{	get [Symbol.isConcatSpreadable](){ return this[ArrayUtils.spreadable]; }	get [ArrayUtils.spreadable](){ return false; }// spreadable push, shift, ...	/**	 * clone an array	 * we use "for" instead of "slice" and "push.apply" because it's faster	 */	clone(){ return this.slice(0) }	/**	 * get first element that matches a condition	 * @param {function} 	condition 	desired condition	 * @param {int} 		index 		optional start index	 * @param {int} 		lastIndex 	optional last index	 */	first(condition, index = 0, lastIndex){		var len	= this.length;		if(len > 0){			if(arguments.length === 0)				return this[0];			else {				if(lastIndex && lastIndex < len) len = lastIndex + 1;				if(index < 0) throw new Error('incorrect index: ' + index);				while(index < len){					if(condition(this[index], index, this) === true)						return this[index];					++index;				}			}		}	}	/**	 * get the last element that matches a condition	 * @param {function} condition desired condition	 * @param {int} index last index	 */	last(condition, beginIndex = 0, lastIndex){		var len	= this.length - 1;		if(len > -1){			if(arguments.length === 0)				return this[len];			else {				if(lastIndex && lastIndex <= len) len = lastIndex;				if(beginIndex < 0) throw new Error('incorrect index: ' + index);				for(var i = len; i >= beginIndex; i--){					if(condition(this[i], i, this) === true)						return this[i];				}			}		}	}	/** contains */	contains(ele){ return this.indexOf(ele) !== -1; }	// push(){ return _arrayUtilsPush(this, arguments, 'push'); }	// unshift(){ return _arrayUtilsPush(this, arguments, 'unshift'); }	/**	 * each	 */	each(cb){		for(var i=0, len = this.length; i < len; ++i){			if(cb(this[i], i) === false)				break;		}		return this;	}	/** remove all elemnts */	clear(){		this.splice(0);		return this;	}	unique(){		return this.filter((ele, indx) => {			return this.indexOf(ele) === indx;		});	}	eq(index){		if(index < 0){			index += this.length;			if(index < 0) return undefined;		}		return this[index];	}}Object.defineProperties(ArrayUtilsFactory.prototype, {	contains	: {value: Array.prototype.includes},	has			: {value: Array.prototype.includes},	duplicate	: {value: ArrayUtilsFactory.prototype.clone}})// instanceofArrayUtils.prototype = ArrayUtilsFactory.prototype;// Array.from(arrayLikeElement, mapFunction)// Array.copyWithin// Array.fill// // // every// some// // reverse// sort// concat// splice// // map// reduce// reduceRight// // indexOf// join// lastIndexOf// slice// // entries// filter// find// findIndex// // forEach// push// function _arrayUtilsPush(lst, args, operation){// 	var control	= lst[ArrayUtils.control];// 	// native push or unshift// 	var push	= Array.prototype[operation].call;// 	// push each element with control// 	var pushElement;// 	if(typeof control === 'function')// 		pushElement = (ele => {// 			if(control(ele) === true)// 				push(lst, ele);// 		});// 	else// 		pushElement= (ele => push(lst, ele));// 	// spreadable// 	var pushAll;// 	if(lst[ArrayUtils.spreadable] === true)// 		pushAll	= (lst => {// 			for(var i=0, len = lst.length; i<len; ++i){// 				if(ArrayUtils.isArrayLike(lst[i]))// 					pushAll(lst[i]);// 				else// 					pushElement(lst[i]);// 			}// 		});// 	else// 		pushAll	= (lst => {// 			for(var i=0, len = lst.length; i<len; ++i)// 				pushElement(lst[i]);// 		});// 	// push// 	pushAll(args);// }